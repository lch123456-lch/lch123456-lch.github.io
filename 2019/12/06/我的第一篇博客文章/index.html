<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的第一篇博客文章 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的第一篇文章 第一个Jsp&#x2F;servlet 1、说一说Servlet生命周期Servlet的生命周期分为三部分 初始化：Web容器加载servlet，调用init()方法进行初始化。 处理请求：当请求到达时，运行其service()方法。Service()会根据表单的请求类型调用相对doGet()方法或者是doPost()方法。 销毁：当服务器关闭时，调用distroy()方法销毁servlet">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第一篇博客文章">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;06&#x2F;%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="我的第一篇文章 第一个Jsp&#x2F;servlet 1、说一说Servlet生命周期Servlet的生命周期分为三部分 初始化：Web容器加载servlet，调用init()方法进行初始化。 处理请求：当请求到达时，运行其service()方法。Service()会根据表单的请求类型调用相对doGet()方法或者是doPost()方法。 销毁：当服务器关闭时，调用distroy()方法销毁servlet">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-06T13:36:24.667Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-我的第一篇博客文章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="article-date">
  <time datetime="2019-12-06T11:15:17.807Z" itemprop="datePublished">2019-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      我的第一篇博客文章
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我的第一篇文章</p>
<p>第一个<br>Jsp/servlet</p>
<p>1、说一说Servlet生命周期<br>Servlet的生命周期分为三部分</p>
<p>初始化：Web容器加载servlet，调用init()方法进行初始化。</p>
<p>处理请求：当请求到达时，运行其service()方法。Service()会根据表单的请求类型调用相对doGet()方法或者是doPost()方法。</p>
<p>销毁：当服务器关闭时，调用distroy()方法销毁servlet。</p>
<p>2、get提交和post提交有何区别<br>get一般用于从服务器上获取数据，post一般用于向服务器传送数据。</p>
<p>get的请求参数是拼接在url后面，可以在浏览器地址栏看见，post是放在http包的包体中。</p>
<p>get方法提交的数据只能是文本，大小不能超过1024个字节，而post不仅可以提交文本还有二进制文件。所以要上传文件，就使用post请求方式。</p>
<p>3、jsp与servlet有什么区别<br>jsp的本质就是一个servlet 他会被容器转化成servlet，在编译成class文件  调用jspService()处理请求。</p>
<p>jsp注重的是页面展示     servlet注重的是流程控制和事务处理</p>
<p>4、doGet与doPost方法的两个参数是什么<br>HttpServletRequest：封装了与请求相关的信息</p>
<p>HttpServletResponse：封装了与响应相关的信息</p>
<p>5、request.getAttribute()和request.getParameter的区别？<br>1.有setAttribute，没有setParameter方法 </p>
<p>2.getParameter获取到的值只能是字符串，不可以是对象，而getAttribute获取到的值是Object类型的。</p>
<p>3.getParameter获取from表单传递过来的值；getAttribute只能获取使用setAttribute设置的值。</p>
<p>6、jsp有哪些内置对象，作用是什么<br>request：包含用户端请求的信息</p>
<p>response：包含服务器传回客户端的响应信息</p>
<p>session：与请求有关的会话期</p>
<p>pageContext：管理网页属性</p>
<p>application：服务器启动时创建，服务器关闭时停止，为多个应用程序保存信息</p>
<p>out：向客户端输出数据</p>
<p>config：servlet的架构部件</p>
<p>page：指网页本身</p>
<p>exception：针对错误页面才可使用</p>
<p>7、四种会话跟踪技术作用域<br>page：一个页面</p>
<p>request：：一次请求</p>
<p>session：一次会话</p>
<p>application：服务器从启动到停止。</p>
<p>8、JSP中动态INCLUDE和静态INCLUDE有什么区别<br>（动态包含使用&lt;jsp:include page=””&gt;使用page属性实现。）</p>
<p>（静态包含使用&lt;%@include file=””&gt;使用file属性实现。）</p>
<p>Include指令用于把另外一个页面包含到当前页面中，在转换成servlet的时候包含进去的。</p>
<p>动态include用动作实现，它总会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。</p>
<p>静态include用伪码实现，不会检查所包含的文件变化，使用于包含静态页面</p>
<p>9、forward和redirect的区别<br>请求转发与重定向</p>
<p>请求转发：服务器内部跳转，浏览器地址栏的地址不变，重定向：告诉浏览器，发送二次跳转。</p>
<p>请求转发：可以共享request里面的数据，重定向：不能共享数据。</p>
<p>请求转发：只能在同一个项目跳转，重定向：可以跨域访问。</p>
<p>请求转发：效率高，重定向：效率低。</p>
<p>10、 说出JSP的6个动作指令和作用？<br>jsp:include：在页面被请求的时候引入一个静态或动态的文件。</p>
<p>jsp:useBean：实力化一个对象。</p>
<p>jsp:setProperty：设置对象的属性。</p>
<p>jsp:getProperty：获取对象的属性。</p>
<p>jsp:forward：请求转发。</p>
<p>11、JSP的3种跳转方式<br>response.sendRedirct()方法：重新发送请求。</p>
<p>response.setHeader()方法：重新发送请求但可以设置等待的时间。</p>
<p>&lt;jsp:forward page=”跳转的页面”/&gt;：请求转发，服务器的跳转。</p>
<p>12、 谈谈Servlet过滤器的作用？<br>在请求到达servlet之前，执行过滤器，过滤器决定是否执行(可以进行权限控制)，可以提前设置一些参数(比如在执行action前设置统一字符集)。</p>
<p>当你在执行一个方法，在这个方法前或方法后执行一些方法(防止重复提交)。</p>
<p>13、 谈谈Servlet监听器的作用<br>对特定的事件进行监听，当产生这些事件的时候，会执行监听器的代码，分为生命周期监听器和数据变化监听器(统计在线人数(监听session)、网站的访问量(request))。</p>
<p>14、 请简要描述jstl<br> JSP标准标签库（JSTL）是一个JSP标签集合，它封装了核心库</p>
<p>c标签，fmt格式化标签，fn字符串处理标签，sql标签，xml标签。Jstl还提供了实现自定义标签功能，方便我们的页面控件编写。</p>
<p>15、 如何现实servlet的单线程模式<br> Jsp修改page指令   &lt;%@ page isThreadSafe=”false”%&gt;，将编译后的servlet实现SingleThreadModel接口。</p>
<p>16、介绍el表达式<br>EL表达式全名是Expression Language</p>
<p>EL表达式一般操作的是作用域(page、request、session、application)中的属性，使用${标识符}.</p>
<p>17、 tomcat如何调优<br>对jvm的堆的最大值修改为可用内存的80%(修改catalina.bat的相关参数)。</p>
<p>禁用DNS查询(直接使用IP地址访问)。</p>
<p>修改最大线程连接数。</p>
<p>设置超时机制。</p>
<p>18、 tomcat部署的方式有几种<br>1.将web项目文件拷贝到webapps目录中。</p>
<p>2.在tomcat中的conf目录下修改server.xml文件，在host节点中添加<context>标签。并指向项目所在路径。</p>
<p>3.在tomcat中conf\Catalina\localhost目录下添加一个xml文件 文件名可用随意取，并写入一个<context>标签，并指向项目所在路径。</p>
<p>4.用tomcat在线后台管理器，一般tomcat都打开了，直接上传war就可以</p>
<p>Springmvc<br>Hadoop<br>25. Hadoop<br>25.1.1.<br>概念<br>就是一个大数据解决方案。套分布式系统基础架构。 核心内容包含 hdfs 和 mapreduce。hadoop2.0 以后引入 yarn.<br>hdfs 是提供数据存储的，mapreduce 是方便数据计算的。<br>1、HDFS写入数据过程分析<br>2、HDFS读取文件过程分析<br>3、HDFS容错机制：故障类型及监测方法<br>4、HDFS容错机制：读写容错方法<br>5、HDFS容错机制：数据节点（DN）失效策略<br>6、HDFS备份容错规则<br>ZooKeeper<br>它是一个为分布式应用提供一致性服务的软件<br>ZooKeeper的基本运转流程：<br>1、选举Leader。<br>2、同步数据。<br>3、选举Leader过程中算法有很多，但要达到的选举标准是一致的。<br>4、Leader要具有最高的执行ID，类似root权限。<br>5、集群中大多数的机器得到响应并接受选出的Leader。<br>网站流量统计是改进网站服务的重要手段之一，通过获取用户在网站的行为数据，比如点击一个链接，进行分析,得到有价值的信息。<br>主要分析的数据是访问量 也叫 点击量，独立访客数，一天之内会话的总的数量，跳出率，新增独立访客数等等。<br>主要是网页埋点，日志收集，数据清洗，离线分析，利用sqoop从hive中导出数据到mysql。<br>1.日志收集使用flume配置agent文件然后写到hdfs里面<br>a.在日志服务器应用中导入Log4jAppernder相关开发包<br>b.配置log4j配置文件，实现发送日志给flume<br>c.在日志服务器的LogServlet中，通过log4j来发送日志<br>2.数据清洗<br>a清洗目标<br>只保留需要的字段<br>将会话信息拆分<br>b创建外部分区表管理已经在HDFS的流量数据<br>c增加flux的分区信息<br>创建数据清洗表dataclear<br>从zebra表中导入数据到dataclear表，在这个过程中完成数据清洗<br>3.数据处理<br>1.利用Hive实现业务指标的计算<br>2.将计算结果存入统计表<br>4.数据分析</p>
<p>会计网校<br>学员管理，商品管理，运营管理，内容管理，考试管理，用户管理，系统管理，活动管理<br>1.批量导入功能：先下载excel表格的模板，然后里面写入学员的信息，然后进行存储。<br>2.批量复制课次功能：先批量选中，然后进行选择相应的课程，然后进行复制。主要是写了一个插件来协助完成<br>3.活动课程二维码接口：主要是调用达内这边封装的方法生成<br>但是我下来了解到生成二维码的方法有3种及时分别用各种的包<br>Qrcode</p>
<p>电子合同<br>主要是生成公司员工要签署的一系列的合同模板，例如入职，离职，续约，实习生协议等等<br>1.在ui页面切换的时候，就得先找到原来的页面，然后对jsp进行修改，然后修改标题<br>background-size:contain;<br>2.在修改bug那个问题就是先了解平台的系统管理的系统资源管理和菜单管理的各个资源，发现有个菜单的资源都是首页的资源，然后修改了资源就好了</p>
<p>Python<br>1.爬虫的基本流程<br>发起请求<br>通过HTTP库向目标站点发起请求，也就是发送一个Request，请求可以包含额外的header等信息，等待服务器响应。<br>获取响应内容<br>如果服务器能正常响应，会得到一个Response，Response的内容便是所要获取的页面内容，类型可能是HTML,Json字符串，二进制数据（图片或者视频）等类型<br>解析内容<br>得到的内容可能是HTML,可以用正则表达式，页面解析库进行解析，可能是Json,可以直接转换为Json对象解析，可能是二进制数据，可以做保存或者进一步的处理<br>保存数据<br>保存形式多样，可以存为文本，也可以保存到数据库，或者保存特定格式的文件</p>
<p>Spring Boot<br>Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。</p>
<p>2.2、SpringBoot四个主要特性</p>
<p>1、SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；</p>
<p>2、自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；</p>
<p>3、命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；</p>
<p>4、Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。但首先，我们快速了解每项特性，更好的体验他们如何简化Spring编程模型。<br>异常</p>
<p>Java中的异常有哪几类？分别怎么使用？<br>Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)<br>(1) Error是程序无法处理了, 如果OutOfMemoryError、OutOfMemoryError等等, 这些异常发生时, java虚拟机一般会终止线程 .<br>(2) 运行时异常都是RuntimeException类及其子类,如 NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉. 这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免.<br>(3) 检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等</p>
<p>用Axure画的相关的原型图</p>
<p>怎么配置tomacat的端口号<br>1.修改端口:<br>在Tomcat的安装目录下的\conf目录下,打开server.xml,<br>找到<br><Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"
redirectPort="8443"/><br>将8080改为你想要的端口8081</p>
<p>2.映射路径:<br>还是在server.xml配置文件中,<br>在</host>这个结束标签之前加上如下的配置信息:<br><Context
path="/myapp"
reloadable="true"
docBase="e:\myApp" /></p>
<p>3.添加端口:<br>在server.xml中添加以下:<br><Connector port="65535" protocol="HTTP/1.1"
connectionTimeout="20000" /><br>Tomcat的端口号最大到65535.</p>
<p>Jvm</p>
<p>1） 类装载器（ClassLoader）（用来装载.class文件）<br>2） 执行引擎（执行字节码，或者执行本地方法）<br>3） 运行时数据区（方法区、堆、虚拟机栈、程序计数器、本地方法栈）<br>首先我们对运行时数据区中的5个区域进行分析：<br>3. 运行时数据区：<br>3.1 堆：<br>所有线程共享的内存区域，在虚拟机启动时创建。<br>用来存储对象实例，如：String a = new String()中new String()创建了一个对象，该对象存放在堆内存中，而a 是存放在栈中的，堆中new String() 存放了栈中 a 的内存地址。<br>可以通过-Xmx和-Xms控制堆的大小<br>当在堆中没有内存完成实例分配，且堆也无法再扩展时，会报OutOfMemoryError异常。<br>java堆是垃圾回收器的主要工作区域。java对还可以分为新生代、老年代。但是垃圾回收器的永久代是在方法区中的，不在堆中。<br>（新生代：新建的对象由新生代分配内存；老年代：存放经过多次垃圾回收器回收仍然存活的对象；永久代：存放静态文件，如java类、方法等，永久代存放在方法区，对垃圾回收没有显著的影响）<br>3.1.1 新生代：<br>分为三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。<br>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。<br>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。（动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。）经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<br>GC可分为三种：Minor GC Major GC 和 Full GC<br>Minor GC ：是清理新生代。触发条件：当Eden区满时，触发Minor GC。<br>Major GC：是清理老年代。是 Major GC 还是 Full GC，大家应该关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程。<br>Full GC ：是清理整个堆空间—包括年轻代和老年代。触发条件：调用System.gc时，系统建议执行Full GC，但是不必然执行;老年代空间不足;方法区空间不足；通过Minor GC后进入老年代的平均大小大于老年代的可用内存；由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小<br>3.1.2 老年代：<br>主要存放应用程序中生命周期长的内存对象。<br>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。<br>MajorGC采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。<br>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。<br> 3.1.3 永久代（永久代是在方法区中的，而不在堆中，这里只是为了总结GC的运行机制并和新生代、老年代进行比较才将永久代放在这里写）：<br>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。<br>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的MetaSpace区域所取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制.采用元空间取代永久代的原因：（1）为了解决永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出。（2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出（因为堆空间有限，此消彼长）。（3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低（4）Oracle 可能会将HotSpot 与 JRockit 合二为一。<br>3.2 方法区：<br>所有线程共享<br>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>当方法区无法满足内存的分配需求时，报OutOfMemoryError异常<br>方法区中有一个运行时常量池，用于存储编译期生成的各种字面量与符号引用，当常量池无法再申请到内存时报OutOfMemoryError异常。<br>3.3 虚拟机栈：<br>线程私有，声明周期与线程同步。<br>存储一些方法的局部变量表（基本类型、对象引用）、操作数栈、动态链接、方法出口等信息。<br>每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建的时候被创建。<br>每个方法执行的同时都会创建一个栈帧，每个方法被调用直至完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。<br>当线程请求的栈深度大于虚拟机允许的深度时报StackOverFlowError异常。<br>当栈的扩展无法申请到足够的内存时报OutOfMemoryError异常。<br>3.4 本地方法栈：<br>主要是为虚拟机使用到的Native方法服务，Native 方法就是一个java调用非java代码的接口，该方法的实现由非java语言实现。Native方法用native修饰，没有方法体，因为方法体中的实现是非java语言的。<br>有时java需要调用操作系统的一些方法，而操作系统基本都是C语言写的，这时就需要使用到Native方法了。<br>Native方法关键字修饰的方法是一个原生态的方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI（Java Native Interface）接口调用其他语言来实现对底层的访问。<br>3.5 程序计数器：<br>当前线程所执行的字节码的行号指示器，当前线程私有，由于他只是存储行号，一般就是一个数字，所以不会出现OutOfMemoryError异常。<br>其特点是：如果正在执行java方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行Native方法，则这个计数器为空（undefined），此内存区域是唯一一个在java虚拟机中没有规定任何OutOfMemoryError异常情况的区域。<br>使用场景：A线程先获取CPU时间片执行，当执行到一半的时候，B线程过来了，且优先级比A线程的高，所以处理器又去执行B线程了，把A线程挂起，当B线程执行完了以后，再回过头来执行A线程，这时就需要知道A线程已经执行的位置，也就是查看A中的程序计数器中的指令。</p>
<p>总结：java对象存放在堆中，常量存放在方法区的常量池中，虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据放在方法区，以上区域都是线程共享的。栈是线程私有的，存放该方法的局部变量（基本类型、对象引用）操作数栈、动态链接、方法出口等信息。一个java程序对应一个JVM，一个方法对应一个java栈。</p>
<p>Java<br>java语言的优缺点<br>角度一：<br>优点：简单、安全、稳定、跨平台<br>缺点：需要运行环境、不适合开发桌面应用程序<br>应用：BS结构的ERP系统、金融系统、电子商务系统、网站等<br>几乎所有的银行系统和银行网站都是基于Java平台的，你可以访问看看。<br>角度二：<br>优势：<br>（1）一次编写，到处运行。<br>（2）系统的多平台支持。<br>（3）强大的可伸缩性。<br>（4）多样化和功能强大的开发工具支持。<br>劣势：<br>（1） 与ASP一样，Java的一些优势正是它致命的问题所在。正是由于为了跨平台的功能，为了极度的伸缩能力，所以极大的增加了产品的复杂性。<br>（2） Java的运行速度是用class常驻内存来完成的，所以它在一些情况下所使用的内存比起用户数量来说确实是“最低性能价格比”了。从另一方面，它还需要硬盘空间来储存一系列的。java文件和.class文件，以及对应的版本文件。<br>角度三：<br>1、跨平台性，虽然是很好的优势，可以让JAVA在任何的系统中运行，但是前提是该系统要安装JAVA虚拟机，这样导致一些JAVA编写的桌面程序无法在一般的用户（没有安装JAVA虚拟机的用户）上使用<br>2、JAVA的身后是SUN公司，提供及时的API更新，但是过多的版本导致JAVA的向下兼容性很差。而SUN公司在J2EE上的标准定义的并不是完美，导致在J2EE的开发中多数使用开源框架，开源框架是好东西，但是更新速度并不快。<br>3、都说面向对象的语言先进与面向过程，JAVA是OOP语言，但是它适合的是BS系统，在WEB项目中JAVA的实力毋庸置疑，但是转到了底层的程序却无法同C++抗衡。<br>4、个人认为JAVA的最大优点是开源，但是这往往也成了最大的缺陷了，无法定义一个好的标准使得开发时使用了框架，在新的程序员来到公司时必须先了解框架，延缓了开发的时间。</p>
<p>Java中正确打印时间的<br>SimpleDateFormat time=new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>String TimeString = time.format(new java.util.Date());<br>Java中常见常用的类<br>1、Object<br>Object类是所有类的父类<br>2、String<br>3、StringBuilder类<br>4、Scanner<br>5、Math类<br>6、Random类<br>7、Date类<br>8、DateFormat<br>Linux中如何查看日志<br>实时查看日志tail -f /var/log/messages<br>初次设计数据库表中需要注意的问题<br>1、选取最适用的字段属性<br>2、使用连接（JOIN）来代替子查询(Sub-Queries)<br>3、使用联合(UNION)来代替手动创建的临时表<br>4、使用外键<br>5、每个表有一个主键</p>
<p>第二个</p>
<p>第三个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" data-id="ck3uwcczb0004yoqz6aktcjlc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87-md/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          我的第二篇-md
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/07/%E6%88%91%E7%9A%84%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">我的复习资料</a>
          </li>
        
          <li>
            <a href="/2019/12/06/%E6%88%91%E7%9A%842%E6%96%87%E7%AB%A0/">&#39;我的2文章&#39;</a>
          </li>
        
          <li>
            <a href="/2019/12/06/%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/">我的文章</a>
          </li>
        
          <li>
            <a href="/2019/12/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%89%E7%AF%87-md/">我的第三篇-md</a>
          </li>
        
          <li>
            <a href="/2019/12/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87-md/">我的第二篇-md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>